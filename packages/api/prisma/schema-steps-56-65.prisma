// ===== STEPS 56-65: ADVANCED FEATURES & ANALYTICS =====

// Step 56: Video Streaming Platform
model VideoContent {
  id            String              @id @default(cuid())
  tenantId      String
  title         String
  description   String?
  url           String
  thumbnailUrl  String?
  duration      Int                 // in seconds
  views         Int                 @default(0)
  isLive        Boolean             @default(false)
  streamKey     String?             @unique
  uploadedBy    String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  uploader      User                @relation("VideoUploader", fields: [uploadedBy], references: [id])
  analytics     VideoAnalytics[]

  @@map("video_content")
}

model VideoAnalytics {
  id            String              @id @default(cuid())
  tenantId      String
  videoId       String
  userId        String?
  watchTime     Int                 // in seconds
  completionRate Float
  quality       String
  timestamp     DateTime            @default(now())

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  video         VideoContent        @relation(fields: [videoId], references: [id], onDelete: Cascade)
  user          User?               @relation("VideoViewer", fields: [userId], references: [id])

  @@map("video_analytics")
}

// Step 57: Virtual Event System
model VirtualEvent {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  description   String
  startTime     DateTime
  endTime       DateTime
  platform      VirtualPlatform
  meetingUrl    String?
  capacity      Int
  isRecorded    Boolean             @default(false)
  hostId        String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  host          User                @relation("EventHost", fields: [hostId], references: [id])
  attendees     VirtualAttendee[]

  @@map("virtual_events")
}

model VirtualAttendee {
  id            String              @id @default(cuid())
  tenantId      String
  eventId       String
  userId        String
  joinedAt      DateTime            @default(now())
  leftAt        DateTime?
  participated  Boolean             @default(false)

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  event         VirtualEvent        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user          User                @relation("EventAttendee", fields: [userId], references: [id])

  @@unique([eventId, userId])
  @@map("virtual_attendees")
}

// Step 58: Augmented Reality Features
model ARExperience {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  type          ARType
  markerUrl     String?
  modelUrl      String
  metadata      Json                @default("{}")
  isActive      Boolean             @default(true)
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator       User                @relation("ARCreator", fields: [createdBy], references: [id])
  interactions  ARInteraction[]

  @@map("ar_experiences")
}

model ARInteraction {
  id            String              @id @default(cuid())
  tenantId      String
  experienceId  String
  userId        String
  action        String
  duration      Int?                // in seconds
  metadata      Json                @default("{}")
  timestamp     DateTime            @default(now())

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  experience    ARExperience        @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  user          User                @relation("ARUser", fields: [userId], references: [id])

  @@map("ar_interactions")
}

// Step 59: Machine Learning Pipeline
model MLModel {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  type          MLModelType
  version       String
  accuracy      Float?
  framework     String              // tensorflow, pytorch, etc.
  modelUrl      String
  config        Json                @default("{}")
  isActive      Boolean             @default(true)
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator       User                @relation("MLCreator", fields: [createdBy], references: [id])
  predictions   MLPrediction[]
  trainingSessions MLTraining[]

  @@map("ml_models")
}

model MLPrediction {
  id            String              @id @default(cuid())
  tenantId      String
  modelId       String
  input         Json
  output        Json
  confidence    Float
  executionTime Int                 // in milliseconds
  timestamp     DateTime            @default(now())

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  model         MLModel             @relation(fields: [modelId], references: [id], onDelete: Cascade)

  @@map("ml_predictions")
}

model MLTraining {
  id            String              @id @default(cuid())
  tenantId      String
  modelId       String
  datasetUrl    String
  epochs        Int
  batchSize     Int
  learningRate  Float
  loss          Float?
  status        TrainingStatus
  startedAt     DateTime            @default(now())
  completedAt   DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  model         MLModel             @relation(fields: [modelId], references: [id], onDelete: Cascade)

  @@map("ml_training")
}

// Step 60: Data Lake Architecture
model DataLake {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  storage       String              // s3, azure, gcp
  bucket        String
  region        String
  sizeBytes     BigInt
  fileCount     Int
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  datasets      Dataset[]

  @@map("data_lakes")
}

model Dataset {
  id            String              @id @default(cuid())
  tenantId      String
  lakeId        String
  name          String
  format        DataFormat
  schema        Json
  sizeBytes     BigInt
  rowCount      Int?
  tags          Json                @default("[]")
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lake          DataLake            @relation(fields: [lakeId], references: [id], onDelete: Cascade)
  creator       User                @relation("DatasetCreator", fields: [createdBy], references: [id])

  @@map("datasets")
}

// Step 61: Business Process Management
model BusinessProcess {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  description   String?
  bpmnXml       String              // BPMN 2.0 XML
  version       Int                 @default(1)
  isActive      Boolean             @default(true)
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator       User                @relation("ProcessCreator", fields: [createdBy], references: [id])
  instances     ProcessInstance[]

  @@map("business_processes")
}

model ProcessInstance {
  id            String              @id @default(cuid())
  tenantId      String
  processId     String
  status        ProcessStatus
  variables     Json                @default("{}")
  currentTask   String?
  startedBy     String
  startedAt     DateTime            @default(now())
  completedAt   DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  process       BusinessProcess     @relation(fields: [processId], references: [id], onDelete: Cascade)
  starter       User                @relation("ProcessStarter", fields: [startedBy], references: [id])
  tasks         ProcessTask[]

  @@map("process_instances")
}

model ProcessTask {
  id            String              @id @default(cuid())
  tenantId      String
  instanceId    String
  name          String
  type          TaskType
  assignedTo    String?
  status        TaskStatus
  dueDate       DateTime?
  completedAt   DateTime?
  formData      Json?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  instance      ProcessInstance     @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  assignee      User?               @relation("TaskAssignee", fields: [assignedTo], references: [id])

  @@map("process_tasks")
}

// Step 62: Contract Management
model Contract {
  id            String              @id @default(cuid())
  tenantId      String
  title         String
  contractNumber String             @unique
  type          ContractType
  value         Float?
  currency      String              @default("USD")
  startDate     DateTime
  endDate       DateTime
  status        ContractStatus
  parties       Json                @default("[]")
  documentUrl   String?
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator       User                @relation("ContractCreator", fields: [createdBy], references: [id])
  milestones    ContractMilestone[]
  amendments    ContractAmendment[]

  @@map("contracts")
}

model ContractMilestone {
  id            String              @id @default(cuid())
  tenantId      String
  contractId    String
  name          String
  dueDate       DateTime
  amount        Float?
  status        MilestoneStatus
  completedAt   DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contract      Contract            @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@map("contract_milestones")
}

model ContractAmendment {
  id            String              @id @default(cuid())
  tenantId      String
  contractId    String
  amendmentNumber String
  description   String
  effectiveDate DateTime
  documentUrl   String?
  createdBy     String
  createdAt     DateTime            @default(now())

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contract      Contract            @relation(fields: [contractId], references: [id], onDelete: Cascade)
  creator       User                @relation("AmendmentCreator", fields: [createdBy], references: [id])

  @@map("contract_amendments")
}

// Step 63: Vendor Management
model Vendor {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  code          String              @unique
  category      String
  status        VendorStatus
  rating        Float?
  contactInfo   Json
  bankDetails   Json?
  taxId         String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  purchaseOrders PurchaseOrder[]
  evaluations   VendorEvaluation[]

  @@map("vendors")
}

model PurchaseOrder {
  id            String              @id @default(cuid())
  tenantId      String
  vendorId      String
  poNumber      String              @unique
  items         Json                @default("[]")
  totalAmount   Float
  currency      String              @default("USD")
  status        POStatus
  deliveryDate  DateTime?
  createdBy     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  vendor        Vendor              @relation(fields: [vendorId], references: [id])
  creator       User                @relation("POCreator", fields: [createdBy], references: [id])

  @@map("purchase_orders")
}

model VendorEvaluation {
  id            String              @id @default(cuid())
  tenantId      String
  vendorId      String
  period        String              // Q1 2024, etc.
  scores        Json                // quality, delivery, price, service
  overallScore  Float
  evaluatedBy   String
  evaluatedAt   DateTime            @default(now())

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  vendor        Vendor              @relation(fields: [vendorId], references: [id])
  evaluator     User                @relation("VendorEvaluator", fields: [evaluatedBy], references: [id])

  @@map("vendor_evaluations")
}

// Step 64: Project Management
model Project {
  id            String              @id @default(cuid())
  tenantId      String
  name          String
  code          String              @unique
  description   String?
  startDate     DateTime
  endDate       DateTime
  budget        Float?
  status        ProjectStatus
  priority      Priority
  managerId     String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  manager       User                @relation("ProjectManager", fields: [managerId], references: [id])
  tasks         ProjectTask[]
  team          ProjectTeam[]

  @@map("projects")
}

model ProjectTask {
  id            String              @id @default(cuid())
  tenantId      String
  projectId     String
  name          String
  description   String?
  startDate     DateTime
  dueDate       DateTime
  completedAt   DateTime?
  status        TaskStatus
  priority      Priority
  assignedTo    String?
  dependencies  Json                @default("[]")

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  project       Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assignee      User?               @relation("ProjectTaskAssignee", fields: [assignedTo], references: [id])

  @@map("project_tasks")
}

model ProjectTeam {
  id            String              @id @default(cuid())
  tenantId      String
  projectId     String
  userId        String
  role          String
  allocation    Float               // percentage
  startDate     DateTime
  endDate       DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  project       Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user          User                @relation("ProjectTeamMember", fields: [userId], references: [id])

  @@unique([projectId, userId])
  @@map("project_team")
}

// Step 65: Time Tracking
model TimeEntry {
  id            String              @id @default(cuid())
  tenantId      String
  userId        String
  projectId     String?
  taskId        String?
  description   String
  startTime     DateTime
  endTime       DateTime?
  duration      Int?                // in minutes
  billable      Boolean             @default(true)
  rate          Float?
  approvedBy    String?
  approvedAt    DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user          User                @relation("TimeEntryUser", fields: [userId], references: [id])
  approver      User?               @relation("TimeEntryApprover", fields: [approvedBy], references: [id])

  @@index([tenantId, userId, startTime])
  @@map("time_entries")
}

model Timesheet {
  id            String              @id @default(cuid())
  tenantId      String
  userId        String
  periodStart   DateTime
  periodEnd     DateTime
  totalHours    Float
  billableHours Float
  status        TimesheetStatus
  submittedAt   DateTime?
  approvedBy    String?
  approvedAt    DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user          User                @relation("TimesheetUser", fields: [userId], references: [id])
  approver      User?               @relation("TimesheetApprover", fields: [approvedBy], references: [id])

  @@unique([userId, periodStart, periodEnd])
  @@map("timesheets")
}

// New Enums for Steps 56-65
enum VirtualPlatform {
  zoom
  teams
  meet
  webex
  custom
}

enum ARType {
  marker_based
  markerless
  location_based
}

enum MLModelType {
  classification
  regression
  clustering
  nlp
  computer_vision
  time_series
}

enum TrainingStatus {
  pending
  running
  completed
  failed
}

enum DataFormat {
  csv
  json
  parquet
  avro
  orc
}

enum ProcessStatus {
  running
  completed
  failed
  cancelled
  suspended
}

enum TaskType {
  user_task
  service_task
  script_task
  send_task
  receive_task
}

enum TaskStatus {
  pending
  assigned
  in_progress
  completed
  cancelled
}

enum ContractType {
  service
  purchase
  lease
  employment
  nda
  partnership
}

enum ContractStatus {
  draft
  active
  expired
  terminated
  renewed
}

enum MilestoneStatus {
  pending
  completed
  overdue
}

enum VendorStatus {
  active
  inactive
  blacklisted
  pending_approval
}

enum POStatus {
  draft
  approved
  sent
  partial_delivery
  delivered
  closed
}

enum ProjectStatus {
  planning
  active
  on_hold
  completed
  cancelled
}

enum Priority {
  low
  medium
  high
  critical
}

enum TimesheetStatus {
  draft
  submitted
  approved
  rejected
}